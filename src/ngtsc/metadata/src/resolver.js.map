{"version":3,"file":"resolver.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * resolver.ts implements partial computation of expressions, resolving expressions to static\n * values where possible and returning a `DynamicValue` signal when not.\n */\n\nimport * as ts from 'typescript';\n\n/**\n * Represents a value which cannot be determined statically.\n *\n * Use `isDynamicValue` to determine whether a `ResolvedValue` is a `DynamicValue`.\n */\nexport class DynamicValue {\n  /**\n   * This is needed so the \"is DynamicValue\" assertion of `isDynamicValue` actually has meaning.\n   *\n   * Otherwise, \"is DynamicValue\" is akin to \"is {}\" which doesn't trigger narrowing.\n   */\n  private _isDynamic = true;\n}\n\n/**\n * An internal flyweight for `DynamicValue`. Eventually the dynamic value will carry information\n * on the location of the node that could not be statically computed.\n */\nconst DYNAMIC_VALUE: DynamicValue = new DynamicValue();\n\n/**\n * Used to test whether a `ResolvedValue` is a `DynamicValue`.\n */\nexport function isDynamicValue(value: any): value is DynamicValue {\n  return value === DYNAMIC_VALUE;\n}\n\n/**\n * A value resulting from static resolution.\n *\n * This could be a primitive, collection type, reference to a `ts.Node` that declares a\n * non-primitive value, or a special `DynamicValue` type which indicates the value was not\n * available statically.\n */\nexport type ResolvedValue = number | boolean | string | null | undefined | Reference |\n    ResolvedValueArray | ResolvedValueMap | DynamicValue;\n\n/**\n * An array of `ResolvedValue`s.\n *\n * This is a reified type to allow the circular reference of `ResolvedValue` -> `ResolvedValueArray`\n * ->\n * `ResolvedValue`.\n */\nexport interface ResolvedValueArray extends Array<ResolvedValue> {}\n\n/**\n * A map of strings to `ResolvedValue`s.\n *\n * This is a reified type to allow the circular reference of `ResolvedValue` -> `ResolvedValueMap` ->\n * `ResolvedValue`.\n */ export interface ResolvedValueMap extends Map<string, ResolvedValue> {}\n\n/**\n * Tracks the scope of a function body, which includes `ResolvedValue`s for the parameters of that\n * body.\n */\ntype Scope = Map<ts.ParameterDeclaration, ResolvedValue>;\n\n/**\n * Whether or not to allow references during resolution.\n *\n * See `StaticInterpreter` for details.\n */\nconst enum AllowReferences {\n  No = 0,\n  Yes = 1,\n}\n\n/**\n * A reference to a `ts.Node`.\n *\n * For example, if an expression evaluates to a function or class definition, it will be returned\n * as a `Reference` (assuming references are allowed in evaluation).\n */\nexport class Reference {\n  constructor(readonly node: ts.Node) {}\n}\n\n/**\n * Statically resolve the given `ts.Expression` into a `ResolvedValue`.\n *\n * @param node the expression to statically resolve if possible\n * @param checker a `ts.TypeChecker` used to understand the expression\n * @returns a `ResolvedValue` representing the resolved value\n */\nexport function staticallyResolve(node: ts.Expression, checker: ts.TypeChecker): ResolvedValue {\n  return new StaticInterpreter(\n             checker, new Map<ts.ParameterDeclaration, ResolvedValue>(), AllowReferences.No)\n      .visit(node);\n}\n\ninterface BinaryOperatorDef {\n  literal: boolean;\n  op: (a: any, b: any) => ResolvedValue;\n}\n\nfunction literalBinaryOp(op: (a: any, b: any) => any): BinaryOperatorDef {\n  return {op, literal: true};\n}\n\nfunction referenceBinaryOp(op: (a: any, b: any) => any): BinaryOperatorDef {\n  return {op, literal: false};\n}\n\nconst BINARY_OPERATORS = new Map<ts.SyntaxKind, BinaryOperatorDef>([\n  [ts.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)],\n  [ts.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)],\n  [ts.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)],\n  [ts.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)],\n  [ts.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)],\n  [ts.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)],\n  [ts.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)],\n  [ts.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)],\n  [ts.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)],\n  [ts.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)],\n  [ts.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)],\n  [ts.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)],\n  [ts.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)],\n  [ts.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)],\n  [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)],\n  [ts.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))],\n  [ts.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)],\n  [ts.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)]\n]);\n\nconst UNARY_OPERATORS = new Map<ts.SyntaxKind, (a: any) => any>([\n  [ts.SyntaxKind.TildeToken, a => ~a], [ts.SyntaxKind.MinusToken, a => -a],\n  [ts.SyntaxKind.PlusToken, a => +a], [ts.SyntaxKind.ExclamationToken, a => !a]\n]);\n\nclass StaticInterpreter {\n  constructor(\n      private checker: ts.TypeChecker, private scope: Scope,\n      private allowReferences: AllowReferences) {}\n\n  visit(node: ts.Expression): ResolvedValue { return this.visitExpression(node); }\n\n  private visitExpression(node: ts.Expression): ResolvedValue {\n    if (node.kind === ts.SyntaxKind.TrueKeyword) {\n      return true;\n    } else if (node.kind === ts.SyntaxKind.FalseKeyword) {\n      return false;\n    } else if (ts.isStringLiteral(node)) {\n      return node.text;\n    } else if (ts.isNumericLiteral(node)) {\n      return parseFloat(node.text);\n    } else if (ts.isObjectLiteralExpression(node)) {\n      return this.visitObjectLiteralExpression(node);\n    } else if (ts.isIdentifier(node)) {\n      return this.visitIdentifier(node);\n    } else if (ts.isPropertyAccessExpression(node)) {\n      return this.visitPropertyAccessExpression(node);\n    } else if (ts.isCallExpression(node)) {\n      return this.visitCallExpression(node);\n    } else if (ts.isConditionalExpression(node)) {\n      return this.visitConditionalExpression(node);\n    } else if (ts.isPrefixUnaryExpression(node)) {\n      return this.visitPrefixUnaryExpression(node);\n    } else if (ts.isBinaryExpression(node)) {\n      return this.visitBinaryExpression(node);\n    } else if (ts.isArrayLiteralExpression(node)) {\n      return this.visitArrayLiteralExpression(node);\n    } else if (ts.isParenthesizedExpression(node)) {\n      return this.visitParenthesizedExpression(node);\n    } else if (ts.isElementAccessExpression(node)) {\n      return this.visitElementAccessExpression(node);\n    } else if (ts.isAsExpression(node)) {\n      return this.visitExpression(node.expression);\n    } else if (ts.isNonNullExpression(node)) {\n      return this.visitExpression(node.expression);\n    } else if (ts.isClassDeclaration(node)) {\n      return this.visitDeclaration(node);\n    } else {\n      return DYNAMIC_VALUE;\n    }\n  }\n\n  private visitArrayLiteralExpression(node: ts.ArrayLiteralExpression): ResolvedValue {\n    const array: ResolvedValueArray = [];\n    for (let i = 0; i < node.elements.length; i++) {\n      const element = node.elements[i];\n      if (ts.isSpreadElement(element)) {\n        const spread = this.visitExpression(element.expression);\n        if (isDynamicValue(spread)) {\n          return DYNAMIC_VALUE;\n        }\n        if (!Array.isArray(spread)) {\n          throw new Error(`Unexpected value in spread expression: ${spread}`);\n        }\n\n        array.push(...spread);\n      } else {\n        const result = this.visitExpression(element);\n        if (isDynamicValue(result)) {\n          return DYNAMIC_VALUE;\n        }\n\n        array.push(result);\n      }\n    }\n    return array;\n  }\n\n  private visitObjectLiteralExpression(node: ts.ObjectLiteralExpression): ResolvedValue {\n    const map: ResolvedValueMap = new Map<string, ResolvedValue>();\n    for (let i = 0; i < node.properties.length; i++) {\n      const property = node.properties[i];\n      if (ts.isPropertyAssignment(property)) {\n        const name = this.stringNameFromPropertyName(property.name);\n\n        // Check whether the name can be determined statically.\n        if (name === undefined) {\n          return DYNAMIC_VALUE;\n        }\n\n        map.set(name, this.visitExpression(property.initializer));\n      } else if (ts.isShorthandPropertyAssignment(property)) {\n        const symbol = this.checker.getShorthandAssignmentValueSymbol(property);\n        if (symbol === undefined || symbol.valueDeclaration === undefined) {\n          return DYNAMIC_VALUE;\n        }\n        map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration));\n      } else if (ts.isSpreadAssignment(property)) {\n        const spread = this.visitExpression(property.expression);\n        if (isDynamicValue(spread)) {\n          return DYNAMIC_VALUE;\n        }\n        if (!(spread instanceof Map)) {\n          throw new Error(`Unexpected value in spread assignment: ${spread}`);\n        }\n        spread.forEach((value, key) => map.set(key, value));\n      } else {\n        return DYNAMIC_VALUE;\n      }\n    }\n    return map;\n  }\n\n  private visitIdentifier(node: ts.Identifier): ResolvedValue {\n    let symbol: ts.Symbol|undefined = this.checker.getSymbolAtLocation(node);\n    if (symbol === undefined) {\n      return DYNAMIC_VALUE;\n    }\n    const result = this.visitSymbol(symbol);\n    if (this.allowReferences === AllowReferences.Yes && isDynamicValue(result)) {\n      return new Reference(node);\n    }\n    return result;\n  }\n\n  private visitSymbol(symbol: ts.Symbol): ResolvedValue {\n    while (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = this.checker.getAliasedSymbol(symbol);\n    }\n\n    if (symbol.declarations === undefined) {\n      return DYNAMIC_VALUE;\n    }\n\n    if (symbol.valueDeclaration !== undefined) {\n      return this.visitDeclaration(symbol.valueDeclaration);\n    }\n\n    return symbol.declarations.reduce<ResolvedValue>((prev, decl) => {\n      if (!(isDynamicValue(prev) || prev instanceof Reference)) {\n        return prev;\n      }\n      return this.visitDeclaration(decl);\n    }, DYNAMIC_VALUE);\n  }\n\n  private visitDeclaration(node: ts.Declaration): ResolvedValue {\n    if (ts.isVariableDeclaration(node)) {\n      if (!node.initializer) {\n        return undefined;\n      }\n      return this.visitExpression(node.initializer);\n    } else if (ts.isParameter(node) && this.scope.has(node)) {\n      return this.scope.get(node) !;\n    } else if (ts.isExportAssignment(node)) {\n      return this.visitExpression(node.expression);\n    } else if (ts.isSourceFile(node)) {\n      return this.visitSourceFile(node);\n    }\n    return this.allowReferences === AllowReferences.Yes ? new Reference(node) : DYNAMIC_VALUE;\n  }\n\n  private visitElementAccessExpression(node: ts.ElementAccessExpression): ResolvedValue {\n    const lhs = this.withReferences.visitExpression(node.expression);\n    if (node.argumentExpression === undefined) {\n      throw new Error(`Expected argument in ElementAccessExpression`);\n    }\n    if (isDynamicValue(lhs)) {\n      return DYNAMIC_VALUE;\n    }\n    const rhs = this.withNoReferences.visitExpression(node.argumentExpression);\n    if (isDynamicValue(rhs)) {\n      return DYNAMIC_VALUE;\n    }\n    if (typeof rhs !== 'string' && typeof rhs !== 'number') {\n      throw new Error(\n          `ElementAccessExpression index should be string or number, got ${typeof rhs}: ${rhs}`);\n    }\n\n    return this.accessHelper(lhs, rhs);\n  }\n\n  private visitPropertyAccessExpression(node: ts.PropertyAccessExpression): ResolvedValue {\n    const lhs = this.withReferences.visitExpression(node.expression);\n    const rhs = node.name.text;\n    // TODO: handle reference to class declaration.\n    if (isDynamicValue(lhs)) {\n      return DYNAMIC_VALUE;\n    }\n\n    return this.accessHelper(lhs, rhs);\n  }\n\n  private visitSourceFile(node: ts.SourceFile): ResolvedValue {\n    const map = new Map<string, ResolvedValue>();\n    const symbol = this.checker.getSymbolAtLocation(node);\n    if (symbol === undefined) {\n      return DYNAMIC_VALUE;\n    }\n    const exports = this.checker.getExportsOfModule(symbol);\n    exports.forEach(symbol => map.set(symbol.name, this.visitSymbol(symbol)));\n\n    return map;\n  }\n\n  private accessHelper(lhs: ResolvedValue, rhs: string|number): ResolvedValue {\n    const strIndex = `${rhs}`;\n    if (lhs instanceof Map) {\n      if (lhs.has(strIndex)) {\n        return lhs.get(strIndex) !;\n      } else {\n        throw new Error(`Invalid map access: [${Array.from(lhs.keys())}] dot ${rhs}`);\n      }\n    } else if (Array.isArray(lhs)) {\n      if (rhs === 'length') {\n        return rhs.length;\n      }\n      if (typeof rhs !== 'number' || !Number.isInteger(rhs)) {\n        return DYNAMIC_VALUE;\n      }\n      if (rhs < 0 || rhs >= lhs.length) {\n        throw new Error(`Index out of bounds: ${rhs} vs ${lhs.length}`);\n      }\n      return lhs[rhs];\n    } else if (lhs instanceof Reference) {\n      const ref = lhs.node;\n      if (ts.isClassDeclaration(ref)) {\n        let value: ResolvedValue = undefined;\n        const member = ref.members.filter(member => isStatic(member))\n                           .find(\n                               member => member.name !== undefined &&\n                                   this.stringNameFromPropertyName(member.name) === strIndex);\n        if (member !== undefined) {\n          if (ts.isPropertyDeclaration(member) && member.initializer !== undefined) {\n            value = this.visitExpression(member.initializer);\n          } else if (ts.isMethodDeclaration(member)) {\n            value = this.allowReferences === AllowReferences.Yes ? new Reference(member) :\n                                                                   DYNAMIC_VALUE;\n          }\n        }\n        return value;\n      }\n    }\n    throw new Error(`Invalid dot property access: ${lhs} dot ${rhs}`);\n  }\n\n  private visitCallExpression(node: ts.CallExpression): ResolvedValue {\n    const lhs = this.withReferences.visitExpression(node.expression);\n    if (!(lhs instanceof Reference)) {\n      throw new Error(`attempting to call something that is not a function: ${lhs}`);\n    } else if (!isFunctionOrMethodDeclaration(lhs.node) || !lhs.node.body) {\n      throw new Error(\n          `calling something that is not a function declaration? ${ts.SyntaxKind[lhs.node.kind]}`);\n    }\n\n    const fn = lhs.node;\n    const body = fn.body as ts.Block;\n    if (body.statements.length !== 1 || !ts.isReturnStatement(body.statements[0])) {\n      throw new Error('Function body must have a single return statement only.');\n    }\n    const ret = body.statements[0] as ts.ReturnStatement;\n\n    const newScope: Scope = new Map<ts.ParameterDeclaration, ResolvedValue>();\n    fn.parameters.forEach((param, index) => {\n      let value: ResolvedValue = undefined;\n      if (index < node.arguments.length) {\n        const arg = node.arguments[index];\n        value = this.visitExpression(arg);\n      }\n      if (value === undefined && param.initializer !== undefined) {\n        value = this.visitExpression(param.initializer);\n      }\n      newScope.set(param, value);\n    });\n\n    return ret.expression !== undefined ? this.withScope(newScope).visitExpression(ret.expression) :\n                                          undefined;\n  }\n\n  private visitConditionalExpression(node: ts.ConditionalExpression): ResolvedValue {\n    const condition = this.withNoReferences.visitExpression(node.condition);\n    if (isDynamicValue(condition)) {\n      return condition;\n    }\n\n    if (condition) {\n      return this.visitExpression(node.whenTrue);\n    } else {\n      return this.visitExpression(node.whenFalse);\n    }\n  }\n\n  private visitPrefixUnaryExpression(node: ts.PrefixUnaryExpression): ResolvedValue {\n    const operatorKind = node.operator;\n    if (!UNARY_OPERATORS.has(operatorKind)) {\n      throw new Error(`Unsupported prefix unary operator: ${ts.SyntaxKind[operatorKind]}`);\n    }\n\n    const op = UNARY_OPERATORS.get(operatorKind) !;\n    const value = this.visitExpression(node.operand);\n    return isDynamicValue(value) ? DYNAMIC_VALUE : op(value);\n  }\n\n  private visitBinaryExpression(node: ts.BinaryExpression): ResolvedValue {\n    const tokenKind = node.operatorToken.kind;\n    if (!BINARY_OPERATORS.has(tokenKind)) {\n      throw new Error(`Unsupported binary operator: ${ts.SyntaxKind[tokenKind]}`);\n    }\n\n    const opRecord = BINARY_OPERATORS.get(tokenKind) !;\n    let lhs: ResolvedValue, rhs: ResolvedValue;\n    if (opRecord.literal) {\n      const withNoReferences = this.withNoReferences;\n      lhs = literal(withNoReferences.visitExpression(node.left));\n      rhs = literal(withNoReferences.visitExpression(node.right));\n    } else {\n      lhs = this.visitExpression(node.left);\n      rhs = this.visitExpression(node.right);\n    }\n\n    return isDynamicValue(lhs) || isDynamicValue(rhs) ? DYNAMIC_VALUE : opRecord.op(lhs, rhs);\n  }\n\n  private visitParenthesizedExpression(node: ts.ParenthesizedExpression): ResolvedValue {\n    return this.visitExpression(node.expression);\n  }\n\n  private stringNameFromPropertyName(node: ts.PropertyName): string|undefined {\n    if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n      return node.text;\n    } else {  // ts.ComputedPropertyName\n      const literal = this.withNoReferences.visitExpression(node.expression);\n      return typeof literal === 'string' ? literal : undefined;\n    }\n  }\n\n  private get withReferences(): StaticInterpreter {\n    return this.allowReferences === AllowReferences.Yes ?\n        this :\n        new StaticInterpreter(this.checker, this.scope, AllowReferences.Yes);\n  }\n\n  private get withNoReferences(): StaticInterpreter {\n    return this.allowReferences === AllowReferences.No ?\n        this :\n        new StaticInterpreter(this.checker, this.scope, AllowReferences.No);\n  }\n\n  private withScope(scope: Scope): StaticInterpreter {\n    return new StaticInterpreter(this.checker, scope, this.allowReferences);\n  }\n}\n\nfunction isStatic(element: ts.ClassElement): boolean {\n  return element.modifiers !== undefined &&\n      element.modifiers.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword);\n}\n\nfunction isFunctionOrMethodDeclaration(node: ts.Node): node is ts.FunctionDeclaration|\n    ts.MethodDeclaration {\n  return ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node);\n}\n\nfunction literal(value: ResolvedValue): any {\n  if (value === null || value === undefined || typeof value === 'string' ||\n      typeof value === 'number' || typeof value === 'boolean') {\n    return value;\n  }\n  if (isDynamicValue(value)) {\n    return DYNAMIC_VALUE;\n  }\n  throw new Error(`Value ${value} is not literal and cannot be used in this context.`);\n}\n"]}