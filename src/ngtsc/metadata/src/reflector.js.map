{"version":3,"file":"reflector.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/reflector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\n/**\n * reflector.ts implements static reflection of declarations using the TypeScript `ts.TypeChecker`.\n */\n\n/**\n * A reflected parameter of a function, method, or constructor, indicating the name, any\n * decorators, and an expression representing a reference to the value side of the parameter's\n * declared type, if applicable.\n */\nexport interface Parameter {\n  /**\n   * Name of the parameter as a `ts.BindingName`, which allows the parameter name to be identified\n   * via sourcemaps.\n   */\n  name: ts.BindingName;\n\n  /**\n   * A `ts.Expression` which represents a reference to the value side of the parameter's type.\n   */\n  typeValueExpr: ts.Expression|null;\n\n  /**\n   * Array of decorators present on the parameter.\n   */\n  decorators: Decorator[];\n}\n\n/**\n * A reflected decorator, indicating the name, where it was imported from, and any arguments if the\n * decorator is a call expression.\n */\nexport interface Decorator {\n  /**\n   * Name of the decorator, extracted from the decoration expression.\n   */\n  name: string;\n\n  /**\n   * Import path (relative to the decorator's file) of the decorator itself.\n   */\n  from: string;\n\n  /**\n   * The decorator node itself (useful for printing sourcemap based references to the decorator).\n   */\n  node: ts.Decorator;\n\n  /**\n   * Any arguments of a call expression, if one is present. If the decorator was not a call\n   * expression, then this will be an empty array.\n   */\n  args: ts.Expression[];\n}\n\n/**\n * Reflect a `ts.ClassDeclaration` and determine the list of parameters.\n *\n * Note that this only reflects the referenced class and not any potential parent class - that must\n * be handled by the caller.\n *\n * @param node the `ts.ClassDeclaration` to reflect\n * @param checker a `ts.TypeChecker` used for reflection\n * @returns a `Parameter` instance for each argument of the constructor, or `null` if no constructor\n */\nexport function reflectConstructorParameters(\n    node: ts.ClassDeclaration, checker: ts.TypeChecker): Parameter[]|null {\n  // Firstly, look for a constructor.\n  // clang-format off\n  const maybeCtor: ts.ConstructorDeclaration[] = node\n    .members\n    .filter(element => ts.isConstructorDeclaration(element)) as ts.ConstructorDeclaration[];\n  // clang-format on\n\n  if (maybeCtor.length !== 1) {\n    // No constructor.\n    return null;\n  }\n\n  // Reflect each parameter.\n  return maybeCtor[0].parameters.map(param => reflectParameter(param, checker));\n}\n\n/**\n * Reflect a `ts.ParameterDeclaration` and determine its name, a token which refers to the value\n * declaration of its type (if possible to statically determine), and its decorators, if any.\n */\nfunction reflectParameter(node: ts.ParameterDeclaration, checker: ts.TypeChecker): Parameter {\n  // The name of the parameter is easy.\n  const name = node.name;\n\n  const decorators = node.decorators &&\n          node.decorators.map(decorator => reflectDecorator(decorator, checker))\n              .filter(decorator => decorator !== null) as Decorator[] ||\n      [];\n\n  // It may or may not be possible to write an expression that refers to the value side of the\n  // type named for the parameter.\n  let typeValueExpr: ts.Expression|null = null;\n\n  // It's not possible to get a value expression if the parameter doesn't even have a type.\n  if (node.type !== undefined) {\n    // It's only valid to convert a type reference to a value reference if the type actually has a\n    // value declaration associated with it.\n    const type = checker.getTypeFromTypeNode(node.type);\n    if (type.symbol !== undefined && type.symbol.valueDeclaration !== undefined) {\n      // The type points to a valid value declaration. Rewrite the TypeReference into an Expression\n      // which references the value pointed to by the TypeReference, if possible.\n      typeValueExpr = typeNodeToValueExpr(node.type);\n    }\n  }\n\n  return {\n      name, typeValueExpr, decorators,\n  };\n}\n\n/**\n * Reflect a decorator and return a structure describing where it comes from and any arguments.\n *\n * Only imported decorators are considered, not locally defined decorators.\n */\nexport function reflectDecorator(decorator: ts.Decorator, checker: ts.TypeChecker): Decorator|null {\n  // Attempt to resolve the decorator expression into a reference to a concrete Identifier. The\n  // expression may contain a call to a function which returns the decorator function, in which\n  // case we want to return the arguments.\n  let decoratorOfInterest: ts.Expression = decorator.expression;\n  let args: ts.Expression[] = [];\n\n  // Check for call expressions.\n  if (ts.isCallExpression(decoratorOfInterest)) {\n    args = Array.from(decoratorOfInterest.arguments);\n    decoratorOfInterest = decoratorOfInterest.expression;\n  }\n\n  // The final resolved decorator should be a `ts.Identifier` - if it's not, then something is\n  // wrong and the decorator can't be resolved statically.\n  if (!ts.isIdentifier(decoratorOfInterest)) {\n    return null;\n  }\n\n  const importDecl = reflectImportedIdentifier(decoratorOfInterest, checker);\n  if (importDecl === null) {\n    return null;\n  }\n\n  return {\n    ...importDecl,\n    node: decorator, args,\n  };\n}\n\nfunction typeNodeToValueExpr(node: ts.TypeNode): ts.Expression|null {\n  if (ts.isTypeReferenceNode(node)) {\n    return entityNameToValue(node.typeName);\n  } else {\n    return null;\n  }\n}\n\nfunction entityNameToValue(node: ts.EntityName): ts.Expression|null {\n  if (ts.isQualifiedName(node)) {\n    const left = entityNameToValue(node.left);\n    return left !== null ? ts.createPropertyAccess(left, node.right) : null;\n  } else if (ts.isIdentifier(node)) {\n    return ts.getMutableClone(node);\n  } else {\n    return null;\n  }\n}\n\nfunction propertyNameToValue(node: ts.PropertyName): string|null {\n  if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n    return node.text;\n  } else {\n    return null;\n  }\n}\n\nexport function reflectObjectLiteral(node: ts.ObjectLiteralExpression): Map<string, ts.Expression> {\n  const map = new Map<string, ts.Expression>();\n  node.properties.forEach(prop => {\n    if (ts.isPropertyAssignment(prop)) {\n      const name = propertyNameToValue(prop.name);\n      if (name === null) {\n        return;\n      }\n      map.set(name, prop.initializer);\n    } else if (ts.isShorthandPropertyAssignment(prop)) {\n      map.set(prop.name.text, prop.name);\n    } else {\n      return;\n    }\n  });\n  return map;\n}\n\nexport function reflectImportedIdentifier(\n    id: ts.Identifier, checker: ts.TypeChecker): {name: string, from: string}|null {\n  const symbol = checker.getSymbolAtLocation(id);\n\n  if (symbol === undefined || symbol.declarations === undefined ||\n      symbol.declarations.length !== 1) {\n    return null;\n  }\n\n  // Ignore decorators that are defined locally (not imported).\n  const decl: ts.Declaration = symbol.declarations[0];\n  if (!ts.isImportSpecifier(decl)) {\n    return null;\n  }\n\n  // Walk back from the specifier to find the declaration, which carries the module specifier.\n  const importDecl = decl.parent !.parent !.parent !;\n\n  // The module specifier is guaranteed to be a string literal, so this should always pass.\n  if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n    // Not allowed to happen in TypeScript ASTs.\n    return null;\n  }\n\n  // Read the module specifier.\n  const from = importDecl.moduleSpecifier.text;\n\n  // Compute the name by which the decorator was exported, not imported.\n  const name = (decl.propertyName !== undefined ? decl.propertyName : decl.name).text;\n\n  return {from, name};\n}\n"]}