{"version":3,"file":"transform.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/transform.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {WrappedNodeExpr, compileIvyInjectable} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {IvyCompilation} from './compilation';\nimport {ImportManager, translateExpression} from './translator';\n\nexport function ivyTransformFactory(compilation: IvyCompilation):\n    ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\n    return (file: ts.SourceFile): ts.SourceFile => {\n      return transformIvySourceFile(compilation, context, file);\n    };\n  };\n}\n\n/**\n * A transformer which operates on ts.SourceFiles and applies changes from an `IvyCompilation`.\n */\nfunction transformIvySourceFile(\n    compilation: IvyCompilation, context: ts.TransformationContext,\n    file: ts.SourceFile): ts.SourceFile {\n  const importManager = new ImportManager();\n\n  // Recursively scan through the AST and perform any updates requested by the IvyCompilation.\n  const sf = visitNode(file);\n\n  // Generate the import statements to prepend.\n  const imports = importManager.getAllImports().map(\n      i => ts.createImportDeclaration(\n          undefined, undefined,\n          ts.createImportClause(undefined, ts.createNamespaceImport(ts.createIdentifier(i.as))),\n          ts.createLiteral(i.name)));\n\n  // Prepend imports if needed.\n  if (imports.length > 0) {\n    sf.statements = ts.createNodeArray([...imports, ...sf.statements]);\n  }\n  return sf;\n\n  // Helper function to process a class declaration.\n  function visitClassDeclaration(node: ts.ClassDeclaration): ts.ClassDeclaration {\n    // Determine if this class has an Ivy field that needs to be added, and compile the field\n    // to an expression if so.\n    const res = compilation.compileIvyFieldFor(node);\n    if (res !== undefined) {\n      // There is a field to add. Translate the initializer for the field into TS nodes.\n      const exprNode = translateExpression(res.initializer, importManager);\n\n      // Create a static property declaration for the new field.\n      const property = ts.createProperty(\n          undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], res.field, undefined, undefined,\n          exprNode);\n\n      // Replace the class declaration with an updated version.\n      node = ts.updateClassDeclaration(\n          node,\n          // Remove the decorator which triggered this compilation, leaving the others alone.\n          maybeFilterDecorator(node.decorators, compilation.ivyDecoratorFor(node) !),\n          node.modifiers, node.name, node.typeParameters, node.heritageClauses || [],\n          [...node.members, property]);\n    }\n\n    // Recurse into the class declaration in case there are nested class declarations.\n    return ts.visitEachChild(node, child => visitNode(child), context);\n  }\n\n  // Helper function that recurses through the nodes and processes each one.\n  function visitNode<T extends ts.Node>(node: T): T;\n  function visitNode(node: ts.Node): ts.Node {\n    if (ts.isClassDeclaration(node)) {\n      return visitClassDeclaration(node);\n    } else {\n      return ts.visitEachChild(node, child => visitNode(child), context);\n    }\n  }\n}\nfunction maybeFilterDecorator(\n    decorators: ts.NodeArray<ts.Decorator>| undefined,\n    toRemove: ts.Decorator): ts.NodeArray<ts.Decorator>|undefined {\n  if (decorators === undefined) {\n    return undefined;\n  }\n  const filtered = decorators.filter(dec => ts.getOriginalNode(dec) !== toRemove);\n  if (filtered.length === 0) {\n    return undefined;\n  }\n  return ts.createNodeArray(filtered);\n}\n"]}