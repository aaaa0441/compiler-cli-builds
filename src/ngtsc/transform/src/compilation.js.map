{"version":3,"file":"compilation.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/compilation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, Type} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Decorator, reflectDecorator} from '../../metadata';\n\nimport {AddStaticFieldInstruction, AnalysisOutput, CompilerAdapter} from './api';\nimport {DtsFileTransformer} from './declaration';\nimport {ImportManager, translateType} from './translator';\n\n\n/**\n * Record of an adapter which decided to emit a static field, and the analysis it performed to\n * prepare for that operation.\n */\ninterface EmitFieldOperation<T> {\n  adapter: CompilerAdapter<T>;\n  analysis: AnalysisOutput<T>;\n  decorator: ts.Decorator;\n}\n\n/**\n * Manages a compilation of Ivy decorators into static fields across an entire ts.Program.\n *\n * The compilation is stateful - source files are analyzed and records of the operations that need\n * to be performed during the transform/emit process are maintained internally.\n */\nexport class IvyCompilation {\n  /**\n   * Tracks classes which have been analyzed and found to have an Ivy decorator, and the\n   * information recorded about them for later compilation.\n   */\n  private analysis = new Map<ts.ClassDeclaration, EmitFieldOperation<any>>();\n\n  /**\n   * Tracks the `DtsFileTransformer`s for each TS file that needs .d.ts transformations.\n   */\n  private dtsMap = new Map<string, DtsFileTransformer>();\n\n  constructor(private adapters: CompilerAdapter<any>[], private checker: ts.TypeChecker) {}\n\n  /**\n   * Analyze a source file and produce diagnostics for it (if any).\n   */\n  analyze(sf: ts.SourceFile): ts.Diagnostic[] {\n    const diagnostics: ts.Diagnostic[] = [];\n    const visit = (node: ts.Node) => {\n      // Process nodes recursively, and look for class declarations with decorators.\n      if (ts.isClassDeclaration(node) && node.decorators !== undefined) {\n        // The first step is to reflect the decorators, which will identify decorators\n        // that are imported from another module.\n        const decorators =\n            node.decorators.map(decorator => reflectDecorator(decorator, this.checker))\n                .filter(decorator => decorator !== null) as Decorator[];\n\n        // Look through the CompilerAdapters to see if any are relevant.\n        this.adapters.forEach(adapter => {\n          // An adapter is relevant if it matches one of the decorators on the class.\n          const decorator = adapter.detect(decorators);\n          if (decorator === undefined) {\n            return;\n          }\n\n          // Check for multiple decorators on the same node. Technically speaking this\n          // could be supported, but right now it's an error.\n          if (this.analysis.has(node)) {\n            throw new Error('TODO.Diagnostic: Class has multiple Angular decorators.');\n          }\n\n          // Run analysis on the decorator. This will produce either diagnostics, an\n          // analysis result, or both.\n          const analysis = adapter.analyze(node, decorator);\n          if (analysis.diagnostics !== undefined) {\n            diagnostics.push(...analysis.diagnostics);\n          }\n          if (analysis.analysis !== undefined) {\n            this.analysis.set(node, {\n              adapter,\n              analysis: analysis.analysis,\n              decorator: decorator.node,\n            });\n          }\n        });\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(sf);\n    return diagnostics;\n  }\n\n  /**\n   * Perform a compilation operation on the given class declaration and return instructions to an\n   * AST transformer if any are available.\n   */\n  compileIvyFieldFor(node: ts.ClassDeclaration): AddStaticFieldInstruction|undefined {\n    // Look to see whether the original node was analyzed. If not, there's nothing to do.\n    const original = ts.getOriginalNode(node) as ts.ClassDeclaration;\n    if (!this.analysis.has(original)) {\n      return undefined;\n    }\n    const op = this.analysis.get(original) !;\n\n    // Run the actual compilation, which generates an Expression for the Ivy field.\n    const res = op.adapter.compile(node, op.analysis);\n\n    // Look up the .d.ts transformer for the input file and record that a field was generated,\n    // which will allow the .d.ts to be transformed later.\n    const fileName = node.getSourceFile().fileName;\n    const dtsTransformer = this.getDtsTransformer(fileName);\n    dtsTransformer.recordStaticField(node.name !.text, res);\n\n    // Return the instruction to the transformer so the field will be added.\n    return res;\n  }\n\n  /**\n   * Lookup the `ts.Decorator` which triggered transformation of a particular class declaration.\n   */\n  ivyDecoratorFor(node: ts.ClassDeclaration): ts.Decorator|undefined {\n    const original = ts.getOriginalNode(node) as ts.ClassDeclaration;\n    if (!this.analysis.has(original)) {\n      return undefined;\n    }\n\n    return this.analysis.get(original) !.decorator;\n  }\n\n  /**\n   * Process a .d.ts source string and return a transformed version that incorporates the changes\n   * made to the source file.\n   */\n  transformedDtsFor(tsFileName: string, dtsOriginalSource: string): string {\n    // No need to transform if no changes have been requested to the input file.\n    if (!this.dtsMap.has(tsFileName)) {\n      return dtsOriginalSource;\n    }\n\n    // Return the transformed .d.ts source.\n    return this.dtsMap.get(tsFileName) !.transform(dtsOriginalSource);\n  }\n\n  private getDtsTransformer(tsFileName: string): DtsFileTransformer {\n    if (!this.dtsMap.has(tsFileName)) {\n      this.dtsMap.set(tsFileName, new DtsFileTransformer());\n    }\n    return this.dtsMap.get(tsFileName) !;\n  }\n}\n"]}