{"version":3,"file":"translator.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/translator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ArrayType, AssertNotNull, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CastExpr, ClassStmt, CommaExpr, CommentStmt, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, JSDocCommentStmt, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, ThrowStmt, TryCatchStmt, Type, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nexport class ImportManager {\n  private moduleToIndex = new Map<string, string>();\n  private nextIndex = 0;\n\n  generateNamedImport(moduleName: string): string {\n    if (!this.moduleToIndex.has(moduleName)) {\n      this.moduleToIndex.set(moduleName, `i${this.nextIndex++}`);\n    }\n    return this.moduleToIndex.get(moduleName) !;\n  }\n\n  getAllImports(): {name: string, as: string}[] {\n    return Array.from(this.moduleToIndex.keys()).map(name => {\n      const as = this.moduleToIndex.get(name) !;\n      return {name, as};\n    });\n  }\n}\n\nexport function translateExpression(expression: Expression, imports: ImportManager): ts.Expression {\n  return expression.visitExpression(new ExpressionTranslatorVisitor(imports), null);\n}\n\nexport function translateType(type: Type, imports: ImportManager): string {\n  return type.visitType(new TypeTranslatorVisitor(imports), null);\n}\n\nclass ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor {\n  constructor(private imports: ImportManager) {}\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitExpressionStmt(stmt: ExpressionStatement, context: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReturnStmt(stmt: ReturnStatement, context: any): ts.ReturnStatement {\n    return ts.createReturn(stmt.value.visitExpression(this, context));\n  }\n\n  visitDeclareClassStmt(stmt: ClassStmt, context: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitIfStmt(stmt: IfStmt, context: any) { throw new Error('Method not implemented.'); }\n\n  visitTryCatchStmt(stmt: TryCatchStmt, context: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitThrowStmt(stmt: ThrowStmt, context: any) { throw new Error('Method not implemented.'); }\n\n  visitCommentStmt(stmt: CommentStmt, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReadVarExpr(ast: ReadVarExpr, context: any): ts.Identifier {\n    return ts.createIdentifier(ast.name !);\n  }\n\n  visitWriteVarExpr(expr: WriteVarExpr, context: any): ts.BinaryExpression {\n    return ts.createBinary(\n        ts.createIdentifier(expr.name), ts.SyntaxKind.EqualsToken,\n        expr.value.visitExpression(this, context));\n  }\n\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWritePropExpr(expr: WritePropExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): ts.CallExpression {\n    return ts.createCall(\n        ast.fn.visitExpression(this, context), undefined,\n        ast.args.map(arg => arg.visitExpression(this, context)));\n  }\n\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): ts.NewExpression {\n    return ts.createNew(\n        ast.classExpr.visitExpression(this, context), undefined,\n        ast.args.map(arg => arg.visitExpression(this, context)));\n  }\n\n  visitLiteralExpr(ast: LiteralExpr, context: any): ts.Expression {\n    if (ast.value === undefined) {\n      return ts.createIdentifier('undefined');\n    } else if (ast.value === null) {\n      return ts.createNull();\n    } else {\n      return ts.createLiteral(ast.value);\n    }\n  }\n\n  visitExternalExpr(ast: ExternalExpr, context: any): ts.PropertyAccessExpression {\n    if (ast.value.moduleName === null || ast.value.name === null) {\n      throw new Error(`Import unknown module or symbol ${ast.value}`);\n    }\n    return ts.createPropertyAccess(\n        ts.createIdentifier(this.imports.generateNamedImport(ast.value.moduleName)),\n        ts.createIdentifier(ast.value.name));\n  }\n\n  visitConditionalExpr(ast: ConditionalExpr, context: any): ts.ParenthesizedExpression {\n    return ts.createParen(ts.createConditional(\n        ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context),\n        ast.falseCase !.visitExpression(this, context)));\n  }\n\n  visitNotExpr(ast: NotExpr, context: any): ts.PrefixUnaryExpression {\n    return ts.createPrefix(\n        ts.SyntaxKind.ExclamationToken, ast.condition.visitExpression(this, context));\n  }\n\n  visitAssertNotNullExpr(ast: AssertNotNull, context: any): ts.NonNullExpression {\n    return ts.createNonNullExpression(ast.condition.visitExpression(this, context));\n  }\n\n  visitCastExpr(ast: CastExpr, context: any): ts.Expression {\n    return ast.value.visitExpression(this, context);\n  }\n\n  visitFunctionExpr(ast: FunctionExpr, context: any): ts.FunctionExpression {\n    return ts.createFunctionExpression(\n        undefined, undefined, ast.name || undefined, undefined,\n        ast.params.map(\n            param => ts.createParameter(\n                undefined, undefined, undefined, param.name, undefined, undefined, undefined)),\n        undefined, ts.createBlock(ast.statements.map(stmt => stmt.visitStatement(this, context))));\n  }\n\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReadPropExpr(ast: ReadPropExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): ts.ObjectLiteralExpression {\n    const entries = ast.entries.map(\n        entry => ts.createPropertyAssignment(\n            entry.quoted ? ts.createLiteral(entry.key) : ts.createIdentifier(entry.key),\n            entry.value.visitExpression(this, context)));\n    return ts.createObjectLiteral(entries);\n  }\n\n  visitCommaExpr(ast: CommaExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any { return ast.node; }\n}\n\nexport class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n  constructor(private imports: ImportManager) {}\n\n  visitBuiltinType(type: BuiltinType, context: any): string {\n    switch (type.name) {\n      case BuiltinTypeName.Bool:\n        return 'boolean';\n      case BuiltinTypeName.Dynamic:\n        return 'any';\n      case BuiltinTypeName.Int:\n      case BuiltinTypeName.Number:\n        return 'number';\n      case BuiltinTypeName.String:\n        return 'string';\n      default:\n        throw new Error(`Unsupported builtin type: ${BuiltinTypeName[type.name]}`);\n    }\n  }\n\n  visitExpressionType(type: ExpressionType, context: any): any {\n    return type.value.visitExpression(this, context);\n  }\n\n  visitArrayType(type: ArrayType, context: any): string {\n    return `Array<${type.visitType(this, context)}>`;\n  }\n\n  visitMapType(type: MapType, context: any): string {\n    if (type.valueType !== null) {\n      return `{[key: string]: ${type.valueType.visitType(this, context)}}`;\n    } else {\n      return '{[key: string]: any}';\n    }\n  }\n\n  visitReadVarExpr(ast: ReadVarExpr, context: any): string {\n    if (ast.name === null) {\n      throw new Error(`ReadVarExpr with no variable name in type`);\n    }\n    return ast.name;\n  }\n\n  visitWriteVarExpr(expr: WriteVarExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWritePropExpr(expr: WritePropExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitLiteralExpr(ast: LiteralExpr, context: any): string {\n    if (typeof ast.value === 'string') {\n      const escaped = ast.value.replace(/\\'/g, '\\\\\\'');\n      return `'${escaped}'`;\n    } else {\n      return `${ast.value}`;\n    }\n  }\n\n  visitExternalExpr(ast: ExternalExpr, context: any): string {\n    if (ast.value.moduleName === null || ast.value.name === null) {\n      throw new Error(`Import unknown module or symbol`);\n    }\n    const base = `${this.imports.generateNamedImport(ast.value.moduleName)}.${ast.value.name}`;\n    if (ast.typeParams !== null) {\n      const generics = ast.typeParams.map(type => type.visitType(this, context)).join(', ');\n      return `${base}<${generics}>`;\n    } else {\n      return base;\n    }\n  }\n\n  visitConditionalExpr(ast: ConditionalExpr, context: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitNotExpr(ast: NotExpr, context: any) { throw new Error('Method not implemented.'); }\n\n  visitAssertNotNullExpr(ast: AssertNotNull, context: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitCastExpr(ast: CastExpr, context: any) { throw new Error('Method not implemented.'); }\n\n  visitFunctionExpr(ast: FunctionExpr, context: any) { throw new Error('Method not implemented.'); }\n\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReadPropExpr(ast: ReadPropExpr, context: any) { throw new Error('Method not implemented.'); }\n\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any) { throw new Error('Method not implemented.'); }\n\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitCommaExpr(ast: CommaExpr, context: any) { throw new Error('Method not implemented.'); }\n\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any) {\n    const node: ts.Node = ast.node;\n    if (ts.isIdentifier(node)) {\n      return node.text;\n    } else {\n      throw new Error(\n          `Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts.SyntaxKind[node.kind]}`);\n    }\n  }\n}"]}