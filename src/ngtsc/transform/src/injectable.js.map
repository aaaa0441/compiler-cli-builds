{"version":3,"file":"injectable.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/injectable.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, IvyInjectableDep, IvyInjectableMetadata, LiteralExpr, WrappedNodeExpr, compileIvyInjectable} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Decorator} from '../../metadata';\nimport {reflectConstructorParameters, reflectImportedIdentifier, reflectObjectLiteral} from '../../metadata/src/reflector';\n\nimport {AddStaticFieldInstruction, AnalysisOutput, CompilerAdapter} from './api';\n\n\n/**\n * Adapts the `compileIvyInjectable` compiler for `@Injectable` decorators to the Ivy compiler.\n */\nexport class InjectableCompilerAdapter implements CompilerAdapter<IvyInjectableMetadata> {\n  constructor(private checker: ts.TypeChecker) {}\n\n  detect(decorator: Decorator[]): Decorator|undefined {\n    return decorator.find(dec => dec.name === 'Injectable' && dec.from === '@angular/core');\n  }\n\n  analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<IvyInjectableMetadata> {\n    return {\n      analysis: extractInjectableMetadata(node, decorator, this.checker),\n    };\n  }\n\n  compile(node: ts.ClassDeclaration, analysis: IvyInjectableMetadata): AddStaticFieldInstruction {\n    const res = compileIvyInjectable(analysis);\n    return {\n      field: 'ngInjectableDef',\n      initializer: res.expression,\n      type: res.type,\n    };\n  }\n}\n\n/**\n * Read metadata from the `@Injectable` decorator and produce the `IvyInjectableMetadata`, the input\n * metadata needed to run `compileIvyInjectable`.\n */\nfunction extractInjectableMetadata(\n    clazz: ts.ClassDeclaration, decorator: Decorator,\n    checker: ts.TypeChecker): IvyInjectableMetadata {\n  if (clazz.name === undefined) {\n    throw new Error(`@Injectables must have names`);\n  }\n  const name = clazz.name.text;\n  const type = new WrappedNodeExpr(clazz.name);\n  if (decorator.args.length === 0) {\n    return {\n      name,\n      type,\n      providedIn: new LiteralExpr(null),\n      useType: getUseType(clazz, checker),\n    };\n  } else if (decorator.args.length === 1) {\n    const metaNode = decorator.args[0];\n    // Firstly make sure the decorator argument is an inline literal - if not, it's illegal to\n    // transport references from one location to another. This is the problem that lowering\n    // used to solve - if this restriction proves too undesirable we can re-implement lowering.\n    if (!ts.isObjectLiteralExpression(metaNode)) {\n      throw new Error(`In Ivy, decorator metadata must be inline.`);\n    }\n\n    // Resolve the fields of the literal into a map of field name to expression.\n    const meta = reflectObjectLiteral(metaNode);\n    let providedIn: Expression = new LiteralExpr(null);\n    if (meta.has('providedIn')) {\n      providedIn = new WrappedNodeExpr(meta.get('providedIn') !);\n    }\n    if (meta.has('useValue')) {\n      return {name, type, providedIn, useValue: new WrappedNodeExpr(meta.get('useValue') !)};\n    } else if (meta.has('useExisting')) {\n      return {name, type, providedIn, useExisting: new WrappedNodeExpr(meta.get('useExisting') !)};\n    } else if (meta.has('useClass')) {\n      return {name, type, providedIn, useClass: new WrappedNodeExpr(meta.get('useClass') !)};\n    } else if (meta.has('useFactory')) {\n      // useFactory is special - the 'deps' property must be analyzed.\n      const factory = new WrappedNodeExpr(meta.get('useFactory') !);\n      const deps: IvyInjectableDep[] = [];\n      if (meta.has('deps')) {\n        const depsExpr = meta.get('deps') !;\n        if (!ts.isArrayLiteralExpression(depsExpr)) {\n          throw new Error(`In Ivy, deps metadata must be inline.`);\n        }\n        if (depsExpr.elements.length > 0) {\n          throw new Error(`deps not yet supported`);\n        }\n        deps.push(...depsExpr.elements.map(dep => getDep(dep, checker)));\n      }\n      return {name, type, providedIn, useFactory: {factory, deps}};\n    } else {\n      const useType = getUseType(clazz, checker);\n      return {name, type, providedIn, useType};\n    }\n  } else {\n    throw new Error(`Too many arguments to @Injectable`);\n  }\n}\n\nfunction getUseType(clazz: ts.ClassDeclaration, checker: ts.TypeChecker): IvyInjectableDep[] {\n  const useType: IvyInjectableDep[] = [];\n  const ctorParams = (reflectConstructorParameters(clazz, checker) || []);\n  ctorParams.forEach(param => {\n    let tokenExpr = param.typeValueExpr;\n    let optional = false, self = false, skipSelf = false;\n    param.decorators.filter(dec => dec.from === '@angular/core').forEach(dec => {\n      if (dec.name === 'Inject') {\n        if (dec.args.length !== 1) {\n          throw new Error(`Unexpected number of arguments to @Inject().`);\n        }\n        tokenExpr = dec.args[0];\n      } else if (dec.name === 'Optional') {\n        optional = true;\n      } else if (dec.name === 'SkipSelf') {\n        skipSelf = true;\n      } else if (dec.name === 'Self') {\n        self = true;\n      } else {\n        throw new Error(`Unexpected decorator ${dec.name} on parameter.`);\n      }\n      if (tokenExpr === null) {\n        throw new Error(`No suitable token for parameter!`);\n      }\n    });\n    const token = new WrappedNodeExpr(tokenExpr);\n    useType.push({token, optional, self, skipSelf});\n  });\n  return useType;\n}\n\nfunction getDep(dep: ts.Expression, checker: ts.TypeChecker): IvyInjectableDep {\n  const depObj = {\n    token: new WrappedNodeExpr(dep),\n    optional: false,\n    self: false,\n    skipSelf: false,\n  };\n\n  function maybeUpdateDecorator(dec: ts.Identifier, token?: ts.Expression): void {\n    const source = reflectImportedIdentifier(dec, checker);\n    if (source === null || source.from !== '@angular/core') {\n      return;\n    }\n    switch (source.name) {\n      case 'Inject':\n        if (token !== undefined) {\n          depObj.token = new WrappedNodeExpr(token);\n        }\n        break;\n      case 'Optional':\n        depObj.optional = true;\n        break;\n      case 'SkipSelf':\n        depObj.skipSelf = true;\n        break;\n      case 'Self':\n        depObj.self = true;\n        break;\n    }\n  }\n\n  if (ts.isArrayLiteralExpression(dep)) {\n    dep.elements.forEach(el => {\n      if (ts.isIdentifier(el)) {\n        maybeUpdateDecorator(el);\n      } else if (ts.isNewExpression(el) && ts.isIdentifier(el.expression)) {\n        const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || undefined;\n        maybeUpdateDecorator(el.expression, token);\n      }\n    });\n  }\n  return depObj;\n}\n"]}