{"version":3,"file":"program.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/ngtsc/program.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {GeneratedFile} from '@angular/compiler';\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport * as api from '../transformers/api';\n\nimport {CompilerHost} from './compiler_host';\nimport {InjectableCompilerAdapter, IvyCompilation, ivyTransformFactory} from './transform';\n\nexport class NgtscProgram implements api.Program {\n  private tsProgram: ts.Program;\n\n  constructor(\n      rootNames: ReadonlyArray<string>, private options: api.CompilerOptions,\n      private host: api.CompilerHost, oldProgram?: api.Program) {\n    this.tsProgram =\n        ts.createProgram(rootNames, options, host, oldProgram && oldProgram.getTsProgram());\n  }\n\n  getTsProgram(): ts.Program { return this.tsProgram; }\n\n  getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken|\n                         undefined): ReadonlyArray<ts.Diagnostic> {\n    return this.tsProgram.getOptionsDiagnostics(cancellationToken);\n  }\n\n  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken|\n                         undefined): ReadonlyArray<api.Diagnostic> {\n    return [];\n  }\n\n  getTsSyntacticDiagnostics(\n      sourceFile?: ts.SourceFile|undefined,\n      cancellationToken?: ts.CancellationToken|undefined): ReadonlyArray<ts.Diagnostic> {\n    return this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n  }\n\n  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken|\n                             undefined): ReadonlyArray<api.Diagnostic> {\n    return [];\n  }\n\n  getTsSemanticDiagnostics(\n      sourceFile?: ts.SourceFile|undefined,\n      cancellationToken?: ts.CancellationToken|undefined): ReadonlyArray<ts.Diagnostic> {\n    return this.tsProgram.getSemanticDiagnostics(sourceFile, cancellationToken);\n  }\n\n  getNgSemanticDiagnostics(\n      fileName?: string|undefined,\n      cancellationToken?: ts.CancellationToken|undefined): ReadonlyArray<api.Diagnostic> {\n    return [];\n  }\n\n  loadNgStructureAsync(): Promise<void> { return Promise.resolve(); }\n\n  listLazyRoutes(entryRoute?: string|undefined): api.LazyRoute[] {\n    throw new Error('Method not implemented.');\n  }\n\n  getLibrarySummaries(): Map<string, api.LibrarySummary> {\n    throw new Error('Method not implemented.');\n  }\n\n  getEmittedGeneratedFiles(): Map<string, GeneratedFile> {\n    throw new Error('Method not implemented.');\n  }\n\n  getEmittedSourceFiles(): Map<string, ts.SourceFile> {\n    throw new Error('Method not implemented.');\n  }\n\n  emit(opts?: {\n    emitFlags?: api.EmitFlags,\n    cancellationToken?: ts.CancellationToken,\n    customTransformers?: api.CustomTransformers,\n    emitCallback?: api.TsEmitCallback,\n    mergeEmitResultsCallback?: api.TsMergeEmitResultsCallback\n  }): ts.EmitResult {\n    const emitCallback = opts && opts.emitCallback || defaultEmitCallback;\n    const mergeEmitResultsCallback = opts && opts.mergeEmitResultsCallback || mergeEmitResults;\n\n    const checker = this.tsProgram.getTypeChecker();\n\n    // Set up the IvyCompilation, which manages state for the Ivy transformer.\n    const adapters = [new InjectableCompilerAdapter(checker)];\n    const compilation = new IvyCompilation(adapters, checker);\n\n    // Analyze every source file in the program.\n    this.tsProgram.getSourceFiles()\n        .filter(file => !file.fileName.endsWith('.d.ts'))\n        .forEach(file => compilation.analyze(file));\n\n    // Since there is no .d.ts transformation API, .d.ts files are transformed during write.\n    const writeFile: ts.WriteFileCallback =\n        (fileName: string, data: string, writeByteOrderMark: boolean,\n         onError: ((message: string) => void) | undefined,\n         sourceFiles: ReadonlyArray<ts.SourceFile>) => {\n          if (fileName.endsWith('.d.ts')) {\n            data = sourceFiles.reduce(\n                (data, sf) => compilation.transformedDtsFor(sf.fileName, data), data);\n          }\n          this.host.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n        };\n\n\n    // Run the emit, including a custom transformer that will downlevel the Ivy decorators in code.\n    const emitResult = emitCallback({\n      program: this.tsProgram,\n      host: this.host,\n      options: this.options,\n      emitOnlyDtsFiles: false, writeFile,\n      customTransformers: {\n        before: [ivyTransformFactory(compilation)],\n      },\n    });\n    return emitResult;\n  }\n}\n\nconst defaultEmitCallback: api.TsEmitCallback =\n    ({program, targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles,\n      customTransformers}) =>\n        program.emit(\n            targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);\n\nfunction mergeEmitResults(emitResults: ts.EmitResult[]): ts.EmitResult {\n  const diagnostics: ts.Diagnostic[] = [];\n  let emitSkipped = false;\n  const emittedFiles: string[] = [];\n  for (const er of emitResults) {\n    diagnostics.push(...er.diagnostics);\n    emitSkipped = emitSkipped || er.emitSkipped;\n    emittedFiles.push(...(er.emittedFiles || []));\n  }\n  return {diagnostics, emitSkipped, emittedFiles};\n}\n"]}